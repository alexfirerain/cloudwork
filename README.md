## CloudWork – облачное хранилище файлов

Программа **CloudWork** представляет собой файловый сервер, предназначенный для работы в составе программного комплекса из трёх компонентов: 
* передовое (лицевое) приложение **NetologyDiplomFrontend**, с которым пользователь работает в своём браузере (предоставлено как-есть в [ТЗ](./TT.md)),
* собственно тыловое (серверное) приложение **CloudWork**, разработанное для согласованной работы с передовым приложением согласно спецификации [CloudServiceSpecification](./CloudServiceSpecification.yaml),
* СУБД (в данной реализации **MySQL**) для персистентного хранения на сервере пользовательских файлов и данных о пользователях.
    

Приложение написано на Java (v17) с использованием каркаса Spring Boot, взаимодействие с БД строится через ORM Hibernate.

## Запуск приложения
Первое, что нужно понимать, это что **CloudWork** это не самодостаточное приложение, а _сервис_, предназначенный для работы в составе _программного комплекса_.  
_Сервис_ выполняет как таковые операции с файлами, но он также нуждается в _СУБД_, где хранятся учётные записи пользователей и их материалы, и в _лицевом приложении_, с которым непосредственно взаимодействует пользователь.
В 

## Принцип работы
Приложение **Cloudwork** производит операции над файлами, принадлежащими зарегистрированным пользователям. Учётные данные зарегистрированных пользователей и их файлы хранятся в БД. Команды на операции считываются из http-запросов, поступающих от лицевого приложения на оконечные адреса (такназываемые "эндпойнты"). Совокупность допустимых для программы запросов и ожидаемых ответов на них называется АПИ и собрана в [спецификацию](./CloudServiceSpecification.yaml).

**Cloudwork** принимает неавторизованные запросы на эндпойнт `"/login"`, служащий для входа в систему, и авторизованные запросы на остальные эндпойнты. Запрос к эндпойнту `"/logout"` соответствует выходу пользователя из системы.

Управление пользователями не входит в функционал программного комплекса, приложение имеет дело с теми учётными записями, которые предоставляются БД. 


### Аутентификация на основе Спринг Секьюрити
Запросы к сервису должны быть авторизованы, т.е. каждый запрос однозначно сопоставлен с зарегистрированным пользователем. Для авторизации от лицевого приложения на `"/login"` приходит джейсон-объект с логином и паролем. Сервис проверяет, что эти учётные данные соответствуют активной учётной записи, и генерирует токен доступа, высылаемый в ответ. Авторизованные запросы должны содержать этот токен в заголовке `auth-token`.


___

Большинство компонентов инициализируется автоматически в рамках каркаса Спринг Бут, для идентификации пользователя используется система авторизации на основе Спринг Секьюрити.
Приложение построено по стандартной слоистой архитектуре с обычным разделением функций:
* _**фильтры**_ осуществляют предварительный анализ запроса и, если запрос содержит идентифицирующую информацию, авторизуют его, т.е. сопоставляют поток обработки запроса с зарегистрированным пользователем;
* _**контроллеры**_ считывают команду и данные из http-запроса, передают их на обработку сервисам и возвращают клиентскому приложению результат выполнения в виде http-ответа;
* _**сервисы**_ отражают основной функционал приложения (такназыаемую "бизнес-логику");
* _**репозитории**_ реализуют взаимодействию с СУБД, т.е. запрашивают данные из хранилища и сохраняют их в нём.

Security filter chain: 
* DisableEncodeUrlFilter
* WebAsyncManagerIntegrationFilter
* SecurityContextHolderFilter
* HeaderWriterFilter
* CorsFilter
* ExceptionHandlerFilter
* TokenFilter
* LogoutFilter
* RequestCacheAwareFilter
* SecurityContextHolderAwareRequestFilter
* SessionManagementFilter
* ExceptionTranslationFilter
* AuthorizationFilter

